From 2816bf49134b76f2ff249a776c32329afb288b07 Mon Sep 17 00:00:00 2001
From: Ricardo Steijn <ricardo.steijn97@gmail.com>
Date: Sat, 20 May 2023 16:49:19 +0200
Subject: [PATCH 1/3] Add support for tearing-control-v1 References:
 https://gitlab.freedesktop.org/wlroots/wlroots/-/merge_requests/3871

--- a/include/sway/commands.h
+++ b/include/sway/commands.h
@@ -184,6 +184,7 @@ sway_cmd cmd_sticky;
 sway_cmd cmd_swaybg_command;
 sway_cmd cmd_swaynag_command;
 sway_cmd cmd_swap;
+sway_cmd cmd_tearing_allowed;
 sway_cmd cmd_tiling_drag;
 sway_cmd cmd_tiling_drag_threshold;
 sway_cmd cmd_title_align;
@@ -295,6 +296,7 @@ sway_cmd output_cmd_render_bit_depth;
 sway_cmd output_cmd_scale;
 sway_cmd output_cmd_scale_filter;
 sway_cmd output_cmd_subpixel;
+sway_cmd output_cmd_tearing_allowed;
 sway_cmd output_cmd_toggle;
 sway_cmd output_cmd_transform;
 sway_cmd output_cmd_unplug;
--- a/include/sway/config.h
+++ b/include/sway/config.h
@@ -285,6 +285,7 @@ struct output_config {
 	int max_render_time; // In milliseconds
 	int adaptive_sync;
 	enum render_bit_depth render_bit_depth;
+	int tearing_allowed;
 
 	char *background;
 	char *background_option;
--- a/include/sway/output.h
+++ b/include/sway/output.h
@@ -56,6 +56,7 @@ struct sway_output {
 	int max_render_time; // In milliseconds
 	struct wl_event_source *repaint_timer;
 	bool gamma_lut_changed;
+	bool tearing_allowed;
 };
 
 struct sway_output_non_desktop {
--- a/include/sway/server.h
+++ b/include/sway/server.h
@@ -17,6 +17,7 @@
 #include <wlr/types/wlr_relative_pointer_v1.h>
 #include <wlr/types/wlr_session_lock_v1.h>
 #include <wlr/types/wlr_server_decoration.h>
+#include <wlr/types/wlr_tearing_control_v1.h>
 #include <wlr/types/wlr_text_input_v3.h>
 #include <wlr/types/wlr_xdg_shell.h>
 #include "config.h"
@@ -120,6 +121,10 @@ struct sway_server {
 	struct wl_listener xdg_activation_v1_new_token;
 
 	struct wl_listener request_set_cursor_shape;
+	
+	struct wlr_tearing_control_manager_v1 *tearing_control_v1;
+	struct wl_listener tearing_control_new_object;
+	struct wl_list tearing_controllers; // sway_tearing_controller::link
 
 	struct wl_list pending_launcher_ctxs; // launcher_ctx::link
 
@@ -186,4 +191,6 @@ void xdg_activation_v1_handle_new_token(struct wl_listener *listener,
 
 void set_rr_scheduling(void);
 
+void handle_new_tearing_hint(struct wl_listener *listener, void *data);
+
 #endif
--- a/include/sway/tree/view.h
+++ b/include/sway/tree/view.h
@@ -32,6 +32,12 @@ enum sway_view_prop {
 #endif
 };
 
+enum sway_view_tearing_mode {
+	TEARING_OVERRIDE_FALSE,
+	TEARING_OVERRIDE_TRUE,
+	TEARING_WINDOW_HINT,
+};
+
 struct sway_view_impl {
 	void (*get_constraints)(struct sway_view *view, double *min_width,
 			double *max_width, double *min_height, double *max_height);
@@ -124,6 +130,9 @@ struct sway_view {
 	int max_render_time; // In milliseconds
 
 	enum seat_config_shortcuts_inhibit shortcuts_inhibit;
+
+	enum sway_view_tearing_mode tearing_mode;
+	bool tearing_hint;
 };
 
 struct sway_xdg_shell_view {
@@ -380,4 +389,6 @@ bool view_is_transient_for(struct sway_view *child, struct sway_view *ancestor);
 
 void view_assign_ctx(struct sway_view *view, struct launcher_ctx *ctx);
 
+bool view_can_tear(struct sway_view *view);
+
 #endif
--- a/protocols/meson.build
+++ b/protocols/meson.build
@@ -14,6 +14,7 @@ protocols = [
 	wl_protocol_dir / 'unstable/linux-dmabuf/linux-dmabuf-unstable-v1.xml',
 	wl_protocol_dir / 'staging/content-type/content-type-v1.xml',
 	wl_protocol_dir / 'staging/cursor-shape/cursor-shape-v1.xml',
+	wl_protocol_dir / 'staging/tearing-control/tearing-control-v1.xml',
 	'wlr-layer-shell-unstable-v1.xml',
 	'idle.xml',
 	'wlr-input-inhibitor-unstable-v1.xml',
--- a/sway/commands.c
+++ b/sway/commands.c
@@ -137,6 +137,7 @@ static const struct cmd_handler command_handlers[] = {
 	{ "splitv", cmd_splitv },
 	{ "sticky", cmd_sticky },
 	{ "swap", cmd_swap },
+	{ "tearing_allowed", cmd_tearing_allowed },
 	{ "title_format", cmd_title_format },
 	{ "unmark", cmd_unmark },
 	{ "urgent", cmd_urgent },
--- a/sway/commands/output.c
+++ b/sway/commands/output.c
@@ -25,6 +25,7 @@ static const struct cmd_handler output_handlers[] = {
 	{ "scale", output_cmd_scale },
 	{ "scale_filter", output_cmd_scale_filter },
 	{ "subpixel", output_cmd_subpixel },
+	{ "tearing_allowed", output_cmd_tearing_allowed },
 	{ "toggle", output_cmd_toggle },
 	{ "transform", output_cmd_transform },
 	{ "unplug", output_cmd_unplug },
--- /dev/null
+++ b/sway/commands/output/tearing_allowed.c
@@ -0,0 +1,22 @@
+#include "sway/commands.h"
+#include "sway/config.h"
+#include "util.h"
+
+struct cmd_results *output_cmd_tearing_allowed(int argc, char **argv) {
+  if (!config->handler_context.output_config) {
+		return cmd_results_new(CMD_FAILURE, "Missing output config");
+	}
+	if (argc == 0) {
+		return cmd_results_new(CMD_INVALID, "Missing tearing_allowed argument");
+	}
+
+  if (parse_boolean(argv[0], true)) {
+    config->handler_context.output_config->tearing_allowed = 1;
+  } else {
+    config->handler_context.output_config->tearing_allowed = 0;
+  }
+
+  config->handler_context.leftovers.argc = argc - 1;
+  config->handler_context.leftovers.argv = argv + 1;
+  return NULL;
+}
\ No newline at end of file
--- /dev/null
+++ b/sway/commands/tearing_allowed.c
@@ -0,0 +1,25 @@
+#include <sway/commands.h>
+#include "sway/config.h"
+#include "sway/tree/view.h"
+#include "util.h"
+
+struct cmd_results *cmd_tearing_allowed(int argc, char **argv) {
+  struct cmd_results *error = NULL;
+	if ((error = checkarg(argc, "tearing_allowed", EXPECTED_AT_LEAST, 1))) {
+		return error;
+	}
+
+  struct sway_container *container = config->handler_context.container;
+  if (!container || !container->view) {
+    return cmd_results_new(CMD_INVALID,
+				"Tearing can only be allowed on views");
+  }
+
+  bool wants_tearing = parse_boolean(argv[0], true);
+
+  struct sway_view *view = container->view;
+  view->tearing_mode = wants_tearing ? TEARING_OVERRIDE_TRUE : 
+    TEARING_OVERRIDE_FALSE;
+
+  return cmd_results_new(CMD_SUCCESS, NULL);
+}
\ No newline at end of file
--- a/sway/config/output.c
+++ b/sway/config/output.c
@@ -76,6 +76,7 @@ struct output_config *new_output_config(const char *name) {
 	oc->adaptive_sync = -1;
 	oc->render_bit_depth = RENDER_BIT_DEPTH_DEFAULT;
 	oc->power = -1;
+	oc->tearing_allowed = -1;
 	return oc;
 }
 
@@ -140,6 +141,9 @@ void merge_output_config(struct output_config *dst, struct output_config *src) {
 	if (src->power != -1) {
 		dst->power = src->power;
 	}
+	if (src->tearing_allowed != -1) {
+		dst->tearing_allowed = src->tearing_allowed;
+	}
 }
 
 static void merge_wildcard_on_all(struct output_config *wildcard) {
@@ -188,12 +192,13 @@ static void merge_id_on_name(struct output_config *oc) {
 			list_add(config->output_configs, ion_oc);
 			sway_log(SWAY_DEBUG, "Generated id on name output config \"%s\""
 				" (enabled: %d) (%dx%d@%fHz position %d,%d scale %f "
-				"transform %d) (bg %s %s) (power %d) (max render time: %d)",
+				"transform %d) (bg %s %s) (power %d) (max render time: %d) "
+				"(tearing allowed: %d)",
 				ion_oc->name, ion_oc->enabled, ion_oc->width, ion_oc->height,
 				ion_oc->refresh_rate, ion_oc->x, ion_oc->y, ion_oc->scale,
 				ion_oc->transform, ion_oc->background,
 				ion_oc->background_option, ion_oc->power,
-				ion_oc->max_render_time);
+				ion_oc->max_render_time, ion_oc->tearing_allowed);
 		}
 	}
 	free(id_on_name);
@@ -234,11 +239,11 @@ struct output_config *store_output_config(struct output_config *oc) {
 
 	sway_log(SWAY_DEBUG, "Config stored for output %s (enabled: %d) (%dx%d@%fHz "
 		"position %d,%d scale %f subpixel %s transform %d) (bg %s %s) (power %d) "
-		"(max render time: %d)",
+		"(max render time: %d) (tearing allowed: %d)",
 		oc->name, oc->enabled, oc->width, oc->height, oc->refresh_rate,
 		oc->x, oc->y, oc->scale, sway_wl_output_subpixel_to_string(oc->subpixel),
 		oc->transform, oc->background, oc->background_option, oc->power,
-		oc->max_render_time);
+		oc->max_render_time, oc->tearing_allowed);
 
 	return oc;
 }
@@ -580,6 +585,12 @@ bool apply_output_config(struct output_config *oc, struct sway_output *output) {
 		output->max_render_time = oc->max_render_time;
 	}
 
+	if (oc && oc->tearing_allowed >= 0) {
+		sway_log(SWAY_DEBUG, "Set %s tearing allowed to %d", 
+			oc->name, oc->tearing_allowed);
+		output->tearing_allowed = oc->tearing_allowed;
+	}
+
 	// Reconfigure all devices, since input config may have been applied before
 	// this output came online, and some config items (like map_to_output) are
 	// dependent on an output being present.
@@ -616,6 +627,7 @@ static void default_output_config(struct output_config *oc,
 	oc->subpixel = output->detected_subpixel;
 	oc->transform = WL_OUTPUT_TRANSFORM_NORMAL;
 	oc->max_render_time = 0;
+	oc->tearing_allowed = 0;
 }
 
 static struct output_config *get_output_config(char *identifier,
@@ -667,11 +679,11 @@ static struct output_config *get_output_config(char *identifier,
 
 		sway_log(SWAY_DEBUG, "Generated output config \"%s\" (enabled: %d)"
 			" (%dx%d@%fHz position %d,%d scale %f transform %d) (bg %s %s)"
-			" (power %d) (max render time: %d)", result->name, result->enabled,
-			result->width, result->height, result->refresh_rate,
-			result->x, result->y, result->scale, result->transform,
-			result->background, result->background_option, result->power,
-			result->max_render_time);
+			" (power %d) (max render time: %d) (tearing allowed: %d)", 
+			result->name, result->enabled, result->width, result->height, 
+			result->refresh_rate, result->x, result->y, result->scale, 
+			result->transform, result->background, result->background_option,
+			result->power, result->max_render_time, result->tearing_allowed);
 	} else if (oc_name) {
 		// No identifier config, just return a copy of the name config
 		free(result->name);
--- a/sway/desktop/output.c
+++ b/sway/desktop/output.c
@@ -420,6 +420,21 @@ bool output_has_opaque_overlay_layer_surface(struct sway_output *output) {
 	return false;
 }
 
+static bool output_can_tear_fullscreen_view(struct sway_output *output, 
+		struct sway_view *view) {
+	if (!view) {
+		return false;
+	}
+#ifdef WLR_HAS_DRM_BACKEND
+	if (wlr_backend_is_drm(output->wlr_output->backend) && 
+			wlr_drm_supports_tearing_page_flips(output->wlr_output->backend) &&
+			output->tearing_allowed && view_can_tear(view)) {
+		return true;
+	}
+#endif
+	return false;
+}
+
 struct send_frame_done_data {
 	struct timespec when;
 	int msec_until_refresh;
@@ -429,8 +444,12 @@ static void send_frame_done_iterator(struct sway_output *output,
 		struct sway_view *view, struct wlr_surface *surface,
 		struct wlr_box *box, void *user_data) {
 	int view_max_render_time = 0;
+	bool view_can_tear = false;
 	if (view != NULL) {
 		view_max_render_time = view->max_render_time;
+		if (view->container && container_is_fullscreen_or_child(view->container)) {
+			view_can_tear = output_can_tear_fullscreen_view(output, view);
+		}
 	}
 
 	struct send_frame_done_data *data = user_data;
@@ -438,7 +457,8 @@ static void send_frame_done_iterator(struct sway_output *output,
 	int delay = data->msec_until_refresh - output->max_render_time
 			- view_max_render_time;
 
-	if (output->max_render_time == 0 || view_max_render_time == 0 || delay < 1) {
+	if (output->max_render_time == 0 || view_max_render_time == 0 || delay < 1 ||
+			view_can_tear) {
 		wlr_surface_send_frame_done(surface, &data->when);
 	} else {
 		struct sway_surface *sway_surface = surface->data;
@@ -556,6 +576,24 @@ static void get_frame_damage(struct sway_output *output,
 	}
 }
 
+static struct sway_view *output_get_fullscreen_view(
+		struct sway_output *output) {
+	struct sway_workspace *workspace = output->current.active_workspace;
+	if (!workspace) {
+		return NULL;
+	}
+
+	struct sway_container *fullscreen_con = root->fullscreen_global;
+	if (!fullscreen_con) {
+		fullscreen_con = workspace->current.fullscreen;
+	}
+	if (fullscreen_con) {
+		return fullscreen_con->view;
+	}
+
+	return NULL;
+}
+
 static int output_repaint_timer_handler(void *data) {
 	struct sway_output *output = data;
 	struct wlr_output *wlr_output = output->wlr_output;
@@ -571,15 +609,7 @@ static int output_repaint_timer_handler(void *data) {
 		return 0;
 	}
 
-	struct sway_workspace *workspace = output->current.active_workspace;
-	if (workspace == NULL) {
-		return 0;
-	}
-
-	struct sway_container *fullscreen_con = root->fullscreen_global;
-	if (!fullscreen_con) {
-		fullscreen_con = workspace->current.fullscreen;
-	}
+	struct sway_view *fullscreen_view = output_get_fullscreen_view(output);
 
 	struct wlr_output_state pending = {0};
 
@@ -601,11 +631,15 @@ static int output_repaint_timer_handler(void *data) {
 	pending.committed |= WLR_OUTPUT_STATE_DAMAGE;
 	get_frame_damage(output, &pending.damage);
 
-	if (fullscreen_con && fullscreen_con->view && !debug.noscanout) {
+	if (output_can_tear_fullscreen_view(output, fullscreen_view)) {
+		wlr_output_state_set_async_page_flip(&wlr_output->pending, true);
+	}
+
+	if (fullscreen_view && !debug.noscanout) {
 		// Try to scan-out the fullscreen view
 		static bool last_scanned_out = false;
 		bool scanned_out =
-			scan_out_fullscreen_view(output, &pending, fullscreen_con->view);
+			scan_out_fullscreen_view(output, &pending, fullscreen_view);
 
 		if (scanned_out && !last_scanned_out) {
 			sway_log(SWAY_DEBUG, "Scanning out fullscreen view on %s",
@@ -742,9 +776,11 @@ static void handle_frame(struct wl_listener *listener, void *user_data) {
 
 	int delay = msec_until_refresh - output->max_render_time;
 
+	struct sway_view *fullscreen_view = output_get_fullscreen_view(output);
+
 	// If the delay is less than 1 millisecond (which is the least we can wait)
-	// then just render right away.
-	if (delay < 1) {
+	// or if the output is allowed to tear, then just render right away.
+	if (delay < 1 || output_can_tear_fullscreen_view(output, fullscreen_view)) {
 		output_repaint_timer_handler(output);
 	} else {
 		output->wlr_output->frame_pending = true;
--- /dev/null
+++ b/sway/desktop/tearing.c
@@ -0,0 +1,60 @@
+#include <wayland-server-core.h>
+#include "sway/server.h"
+#include "sway/tree/view.h"
+#include "log.h"
+
+struct sway_tearing_controller {
+	struct wlr_tearing_control_v1 *tearing_control;
+	struct wl_listener set_hint;
+	struct wl_listener destroy;
+
+	struct wl_list link; // sway_server::tearing_controllers
+};
+
+static void handle_tearing_controller_set_hint(struct wl_listener *listener,
+		void *data) {
+	struct sway_tearing_controller *controller =
+		wl_container_of(listener, controller, set_hint);
+	
+	struct sway_view *view = view_from_wlr_surface(
+		controller->tearing_control->surface);
+	if (view) {
+		view->tearing_hint = controller->tearing_control->hint;
+	}
+}
+
+static void handle_tearing_controller_destroy(struct wl_listener *listener, 
+    void *data) {
+  struct sway_tearing_controller *controller = 
+    wl_container_of(listener, controller, destroy);
+  wl_list_remove(&controller->link);
+	free(controller);
+}
+
+void handle_new_tearing_hint(struct wl_listener *listener, 
+		void *data) {
+	struct sway_server *server = 
+		wl_container_of(listener, server, tearing_control_new_object);
+	struct wlr_tearing_control_v1 *tearing_control = data;
+	
+	enum wp_tearing_control_v1_presentation_hint hint = 
+		wlr_tearing_control_manager_v1_surface_hint_from_surface(
+			server->tearing_control_v1, tearing_control->surface);
+	sway_log(SWAY_DEBUG, "New presentation hint %d received for surface %p",
+		hint, tearing_control->surface);
+
+	struct sway_tearing_controller *controller = 
+		calloc(1, sizeof(struct sway_tearing_controller));
+	if (!controller) {
+		return;
+	}
+
+	controller->tearing_control = tearing_control;
+	controller->set_hint.notify = handle_tearing_controller_set_hint;
+	wl_signal_add(&tearing_control->events.set_hint, &controller->set_hint);
+	controller->destroy.notify = handle_tearing_controller_destroy;
+	wl_signal_add(&tearing_control->events.destroy, &controller->destroy);
+	wl_list_init(&controller->link);
+
+	wl_list_insert(&server->tearing_controllers, &controller->link);
+}
--- a/sway/ipc-json.c
+++ b/sway/ipc-json.c
@@ -396,6 +396,8 @@ static void ipc_json_describe_enabled_output(struct sway_output *output,
 	}
 
 	json_object_object_add(object, "max_render_time", json_object_new_int(output->max_render_time));
+
+	json_object_object_add(object, "tearing_allowed", json_object_new_boolean(output->tearing_allowed));
 }
 
 json_object *ipc_json_describe_disabled_output(struct sway_output *output) {
@@ -589,6 +591,8 @@ static void ipc_json_describe_view(struct sway_container *c, json_object *object
 
 	json_object_object_add(object, "max_render_time", json_object_new_int(c->view->max_render_time));
 
+	json_object_object_add(object, "tearing_allowed", json_object_new_boolean(view_can_tear(c->view)));
+
 	json_object_object_add(object, "shell", json_object_new_string(view_get_shell(c->view)));
 
 	json_object_object_add(object, "inhibit_idle",
--- a/sway/meson.build
+++ b/sway/meson.build
@@ -19,6 +19,7 @@ sway_sources = files(
 	'desktop/output.c',
 	'desktop/render.c',
 	'desktop/surface.c',
+	'desktop/tearing.c',
 	'desktop/transaction.c',
 	'desktop/xdg_shell.c',
 	'desktop/launcher.c',
@@ -111,6 +112,7 @@ sway_sources = files(
 	'commands/swaybg_command.c',
 	'commands/swaynag_command.c',
 	'commands/swap.c',
+	'commands/tearing_allowed.c',
 	'commands/tiling_drag.c',
 	'commands/tiling_drag_threshold.c',
 	'commands/title_align.c',
@@ -200,6 +202,7 @@ sway_sources = files(
 	'commands/output/scale.c',
 	'commands/output/scale_filter.c',
 	'commands/output/subpixel.c',
+	'commands/output/tearing_allowed.c',
 	'commands/output/toggle.c',
 	'commands/output/transform.c',
 	'commands/output/unplug.c',
--- a/sway/server.c
+++ b/sway/server.c
@@ -234,6 +234,13 @@ bool server_init(struct sway_server *server) {
 	server->content_type_manager_v1 =
 		wlr_content_type_manager_v1_create(server->wl_display, 1);
 	wlr_fractional_scale_manager_v1_create(server->wl_display, 1);
+	
+	server->tearing_control_v1 = 
+		wlr_tearing_control_manager_v1_create(server->wl_display, 1);
+	server->tearing_control_new_object.notify = handle_new_tearing_hint;
+	wl_signal_add(&server->tearing_control_v1->events.new_object,
+		&server->tearing_control_new_object);
+	wl_list_init(&server->tearing_controllers);
 
 	struct wlr_xdg_foreign_registry *foreign_registry =
 		wlr_xdg_foreign_registry_create(server->wl_display);
--- a/sway/sway-output.5.scd
+++ b/sway/sway-output.5.scd
@@ -180,6 +180,19 @@ must be separated by one space. For example:
 	updated to work with different bit depths. This command is experimental,
 	and may be removed or changed in the future.
 
+*output* <name> tearing_allowed yes|no
+	Allows or disallows screen tearing as a result of asynchronous page flips,
+	and an immediate presentation mode from a client.
+
+	With asynchronous page flips, frames from the client are presented as soon
+	as possible instead of synchronizing with the monitor's vblank interval 
+	(VSync). This prevents stutter and reduces latency in games.
+
+	To adjust whether tearing is allowed for specific applications, see
+	*tearing_allowed* in *sway*(5).
+
+	This setting only has effect on fullscreen windows.
+
 # SEE ALSO
 
 *sway*(5) *sway-input*(5)
--- a/sway/sway.5.scd
+++ b/sway/sway.5.scd
@@ -353,6 +353,20 @@ set|plus|minus|toggle <amount>
 	becomes fullscreen on the same workspace as the first container. In either
 	of those cases, the second container will gain focus.
 
+*tearing_allowed* yes|no
+	Allows or disallows screen tearing as a result of asynchronous page flips
+	for a fullscreen application.
+
+	When this option is not set, the tearing hints provided by the application
+	determine whether tearing is allowed. When _yes_ is specified,
+	the application allows tearing regardless of the tearing hints.
+	When _no_ is specified, tearing will never be allowed on the application,
+	regardless of the tearing hints.
+
+	This setting only has an effect if tearing is allowed on the output through
+	the per-output *tearing_allowed* setting. See *sway-output*(5) 
+	for further details.
+
 *title_format* <format>
 	Sets the format of window titles. The following placeholders may be used:
 
--- a/sway/tree/view.c
+++ b/sway/tree/view.c
@@ -44,6 +44,7 @@ void view_init(struct sway_view *view, enum sway_view_type type,
 	view->allow_request_urgent = true;
 	view->shortcuts_inhibit = SHORTCUTS_INHIBIT_DEFAULT;
 	wl_signal_init(&view->events.unmap);
+	view->tearing_mode = TEARING_WINDOW_HINT;
 }
 
 void view_destroy(struct sway_view *view) {
@@ -1448,3 +1449,15 @@ bool view_is_transient_for(struct sway_view *child,
 	return child->impl->is_transient_for &&
 		child->impl->is_transient_for(child, ancestor);
 }
+
+bool view_can_tear(struct sway_view *view) {
+	switch(view->tearing_mode) {
+	case TEARING_OVERRIDE_FALSE:
+		return false;
+	case TEARING_OVERRIDE_TRUE:
+		return true;
+	case TEARING_WINDOW_HINT:
+		return view->tearing_hint;
+	}
+	return false;
+}
--- a/swaymsg/main.c
+++ b/swaymsg/main.c
@@ -194,7 +194,7 @@ static void pretty_print_output(json_object *o) {
 	json_object_object_get_ex(o, "current_workspace", &ws);
 	json_object_object_get_ex(o, "non_desktop", &non_desktop);
 	json_object *make, *model, *serial, *scale, *scale_filter, *subpixel,
-		*transform, *max_render_time, *adaptive_sync_status;
+		*transform, *max_render_time, *adaptive_sync_status, *tearing_allowed;
 	json_object_object_get_ex(o, "make", &make);
 	json_object_object_get_ex(o, "model", &model);
 	json_object_object_get_ex(o, "serial", &serial);
@@ -204,6 +204,7 @@ static void pretty_print_output(json_object *o) {
 	json_object_object_get_ex(o, "transform", &transform);
 	json_object_object_get_ex(o, "max_render_time", &max_render_time);
 	json_object_object_get_ex(o, "adaptive_sync_status", &adaptive_sync_status);
+	json_object_object_get_ex(o, "tearing_allowed", &tearing_allowed);
 	json_object *x, *y;
 	json_object_object_get_ex(rect, "x", &x);
 	json_object_object_get_ex(rect, "y", &y);
@@ -257,6 +258,9 @@ static void pretty_print_output(json_object *o) {
 
 		printf("  Adaptive sync: %s\n",
 			json_object_get_string(adaptive_sync_status));
+
+		printf("  Tearing allowed: %s\n",
+			json_object_get_boolean(tearing_allowed) ? "yes" : "no");
 	} else {
 		printf(
 			"Output %s '%s %s %s' (disabled)\n",

From 70b5d3c39c3ffbc12e0af1cc53bca1f7826f5f9e Mon Sep 17 00:00:00 2001
From: Ricardo Steijn <ricardo.steijn97@gmail.com>
Date: Sat, 14 Oct 2023 18:46:12 +0200
Subject: [PATCH 2/3] sway/desktop/output.c: adjust to upstream tearing_control
 changes

--- a/sway/desktop/output.c
+++ b/sway/desktop/output.c
@@ -427,7 +427,6 @@ static bool output_can_tear_fullscreen_view(struct sway_output *output,
 	}
 #ifdef WLR_HAS_DRM_BACKEND
 	if (wlr_backend_is_drm(output->wlr_output->backend) && 
-			wlr_drm_supports_tearing_page_flips(output->wlr_output->backend) &&
 			output->tearing_allowed && view_can_tear(view)) {
 		return true;
 	}
@@ -632,7 +631,7 @@ static int output_repaint_timer_handler(void *data) {
 	get_frame_damage(output, &pending.damage);
 
 	if (output_can_tear_fullscreen_view(output, fullscreen_view)) {
-		wlr_output_state_set_async_page_flip(&wlr_output->pending, true);
+		pending.tearing_page_flip = true;
 	}
 
 	if (fullscreen_view && !debug.noscanout) {
--- a/sway/desktop/tearing.c
+++ b/sway/desktop/tearing.c
@@ -26,8 +26,8 @@ static void handle_tearing_controller_set_hint(struct wl_listener *listener,
 static void handle_tearing_controller_destroy(struct wl_listener *listener, 
     void *data) {
   struct sway_tearing_controller *controller = 
-    wl_container_of(listener, controller, destroy);
-  wl_list_remove(&controller->link);
+		wl_container_of(listener, controller, destroy);
+	wl_list_remove(&controller->link);
 	free(controller);
 }
 

From ede23d95c61a9a09d8e9b61fc258f942ebe5a772 Mon Sep 17 00:00:00 2001
From: Ricardo Steijn <ricardo.steijn97@gmail.com>
Date: Sat, 21 Oct 2023 16:05:14 +0200
Subject: [PATCH 3/3] format

--- a/sway/commands/output/tearing_allowed.c
+++ b/sway/commands/output/tearing_allowed.c
@@ -19,4 +19,4 @@ struct cmd_results *output_cmd_tearing_allowed(int argc, char **argv) {
   config->handler_context.leftovers.argc = argc - 1;
   config->handler_context.leftovers.argv = argv + 1;
   return NULL;
-}
\ No newline at end of file
+}
--- a/sway/commands/tearing_allowed.c
+++ b/sway/commands/tearing_allowed.c
@@ -22,4 +22,4 @@ struct cmd_results *cmd_tearing_allowed(int argc, char **argv) {
     TEARING_OVERRIDE_FALSE;
 
   return cmd_results_new(CMD_SUCCESS, NULL);
-}
\ No newline at end of file
+}
--- a/sway/desktop/tearing.c
+++ b/sway/desktop/tearing.c
@@ -25,7 +25,7 @@ static void handle_tearing_controller_set_hint(struct wl_listener *listener,
 
 static void handle_tearing_controller_destroy(struct wl_listener *listener, 
     void *data) {
-  struct sway_tearing_controller *controller = 
+	struct sway_tearing_controller *controller = 
 		wl_container_of(listener, controller, destroy);
 	wl_list_remove(&controller->link);
 	free(controller);
